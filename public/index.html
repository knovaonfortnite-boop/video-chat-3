<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini FaceTime Chat</title>
  <style>
    * { box-sizing: border-box; margin:0; padding:0 }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background:#000; color:#fff; min-height:100vh; padding:20px; display:flex; flex-direction:column; align-items:center;
    }
    .app {
      width:100%; max-width:1200px;
    }
    .top {
      display:flex; gap:12px; align-items:center; margin-bottom:12px;
    }
    .controls { display:flex; gap:10px; align-items:center; }
    button { padding:10px 16px; border-radius:8px; border:none; cursor:pointer; font-weight:600; }
    #startBtn { background:#10b981; color:#fff }
    #toggleCamBtn { background:#a855f7; color:#fff; }
    #joinBtn { background:#3b82f6;color:#fff }
    #leaveBtn { background:#ef4444;color:#fff }
    .status { margin-left:12px; color:#ddd; font-size:14px }
    .main {
      display:grid; grid-template-columns: 1fr 320px; gap:16px;
    }
    .video-area {
      background:transparent;
    }
    .video-grid {
      display:grid; grid-template-columns: repeat(auto-fit,minmax(280px,1fr)); gap:12px;
    }
    .video-wrapper {
      position:relative; background:#111; border-radius:12px; overflow:hidden; min-height:220px; display:flex; align-items:center; justify-content:center;
    }
    video { width:100%; height:100%; object-fit:cover; display:block; }
    .label {
      position:absolute; bottom:8px; left:8px; background:rgba(0,0,0,0.6); padding:6px 10px; border-radius:8px; color:#fff; font-weight:600;
    }
    .users-panel {
      background: #0b0b0b; padding:12px; border-radius:12px; height:100%;
    }
    .users-panel h3 { margin-bottom:8px; font-size:16px }
    .user-list { display:flex; flex-direction:column; gap:8px; max-height:60vh; overflow:auto; }
    .user-item {
      display:flex; justify-content:space-between; align-items:center; padding:8px; background:rgba(255,255,255,0.02); border-radius:8px;
    }
    .user-item button { padding:8px 10px; background:#2563eb; border-radius:8px; color:#fff; border:none }
    .popup {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.7); z-index:9999;
    }
    .popup-box { background:#111; padding:16px; border-radius:12px; width:320px; text-align:center; }
    .popup-box input { width:100%; padding:10px; margin:8px 0; border-radius:8px; border:none; }
    .cam-off {
      width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size:20px; color:#fff; font-weight:700;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div class="controls">
        <button id="startBtn">Start Camera</button>
        <button id="toggleCamBtn" disabled>Turn Off Camera</button>
        <button id="joinBtn" disabled>Join Call</button>
        <button id="leaveBtn" disabled>Leave Call</button>
      </div>
      <div class="status" id="status">Not connected</div>
    </div>

    <div class="main">
      <div class="video-area">
        <div class="video-grid" id="videoGrid">
          <div class="video-wrapper" id="localWrapper">
            <video id="localVideo" autoplay muted playsinline></video>
            <div class="label" id="localLabel">You</div>
          </div>
        </div>
      </div>

      <aside class="users-panel">
        <h3>Online Users</h3>
        <div class="user-list" id="userList"></div>
      </aside>
    </div>
  </div>

  <!-- Name / room popup (appears when start pressed) -->
  <div id="namePopup" class="popup" style="display:none;">
    <div class="popup-box">
      <h3>Enter your name</h3>
      <input id="nameInput" placeholder="Your name" />
      <button id="nameSubmit">Continue</button>
    </div>
  </div>

  <!-- Incoming call popup -->
  <div id="incomingPopup" class="popup" style="display:none;">
    <div class="popup-box" id="incomingBox">
      <p id="incomingText"></p>
      <div style="display:flex; gap:10px; justify-content:center; margin-top:8px;">
        <button id="acceptBtn" style="background:#10b981;color:#fff">Accept</button>
        <button id="declineBtn" style="background:#ef4444;color:#fff">Decline</button>
      </div>
    </div>
  </div>

  <audio id="ring" src="data:audio/mpeg;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA..."></audio>
  <!-- (base64 short placeholder; you can replace with a real file or URL) -->

  <script>
  // ---------------------------
  // CLIENT: signaling + direct calls
  // ---------------------------

  const wsUrl = (location.protocol === 'https:') ? 'wss://video-chat-3-4.onrender.com' : `ws://${location.host}`;
  let ws;
  let myId = null;
  let myName = null;
  const users = new Map(); // id -> {id, name}
  const pcs = new Map(); // peerId -> RTCPeerConnection
  const localVideo = document.getElementById('localVideo');
  const localLabel = document.getElementById('localLabel');
  const startBtn = document.getElementById('startBtn');
  const toggleCamBtn = document.getElementById('toggleCamBtn');
  const joinBtn = document.getElementById('joinBtn');
  const leaveBtn = document.getElementById('leaveBtn');
  const status = document.getElementById('status');
  const userListEl = document.getElementById('userList');
  const videoGrid = document.getElementById('videoGrid');
  const namePopup = document.getElementById('namePopup');
  const nameInput = document.getElementById('nameInput');
  const nameSubmit = document.getElementById('nameSubmit');
  const incomingPopup = document.getElementById('incomingPopup');
  const incomingText = document.getElementById('incomingText');
  const acceptBtn = document.getElementById('acceptBtn');
  const declineBtn = document.getElementById('declineBtn');
  const ring = document.getElementById('ring');

  let localStream = null;
  let camOffMap = new Map(); // peerId -> cam-off element (for other users)
  let currentCallFrom = null; // id of caller for incoming popup

  const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

  function logStatus(s){ status.textContent = s; console.log(s); }

  // --- connect websocket
  function connectWs() {
    ws = new WebSocket(wsUrl);
    ws.onopen = () => logStatus('Signaling connected');
    ws.onmessage = async (ev) => {
      const msg = JSON.parse(ev.data);
      // console.log('WS recv', msg);
      switch (msg.type) {
        case 'welcome':
          myId = msg.id;
          break;
        case 'user-list':
          handleUserList(msg.users);
          break;
        case 'incoming-call':
          // incoming direct call (offer)
          onIncomingCall(msg.from, msg.fromName, msg.offer);
          break;
        case 'call-accepted':
          // peer answered -> set remote description with answer
          await handleCallAccepted(msg.from, msg.answer);
          break;
        case 'call-declined':
          alert('Call declined');
          break;
        case 'ice-candidate':
          if (pcs.has(msg.from)) {
            try { await pcs.get(msg.from).addIceCandidate(msg.candidate); } catch(e){console.warn(e)}
          }
          break;
        case 'user-left':
          removeUser(msg.id);
          break;
        case 'call-failed':
          alert('Call failed: ' + (msg.reason || 'unknown'));
          break;
        default:
          console.log('Unknown ws msg', msg);
      }
    };
    ws.onclose = () => logStatus('Signaling disconnected');
    ws.onerror = (e) => { console.error(e); logStatus('Signaling error'); };
  }

  // --- populate user list
  function handleUserList(list) {
    userListEl.innerHTML = '';
    users.clear();
    list.forEach(u => {
      users.set(u.id, u);
      if (u.id === myId) return; // don't list self
      const item = document.createElement('div');
      item.className = 'user-item';
      item.innerHTML = `<div>${escapeHtml(u.name)}</div>`;
      const btn = document.createElement('button');
      btn.textContent = 'Call';
      btn.onclick = () => startDirectCall(u.id);
      item.appendChild(btn);
      userListEl.appendChild(item);
    });
  }

  function removeUser(id) {
    users.delete(id);
    // remove their video if present
    const el = document.getElementById('video-' + id);
    if (el) el.remove();
    if (pcs.has(id)) { try { pcs.get(id).close(); } catch(e){} pcs.delete(id); }
  }

  // --- helper to escape
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[m]); }

  // --- start local camera (after name entered)
  startBtn.onclick = async () => {
    // show name popup
    namePopup.style.display = 'flex';
    nameInput.value = '';
    nameInput.focus();
  };

  nameSubmit.onclick = async () => {
    const v = (nameInput.value || '').trim() || 'Anonymous';
    myName = v;
    localLabel.textContent = `${myName} (You)`;
    namePopup.style.display = 'none';

    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
      localVideo.srcObject = localStream;
      toggleCamBtn.disabled = false;
      joinBtn.disabled = false;
      logStatus('Camera on. Registering...');
    } catch (e) {
      alert('Could not access camera/microphone');
      console.error(e);
      return;
    }

    // connect WS and register name
    connectWs();
    // wait for ws open
    const waitOpen = () => new Promise(res => {
      if (ws.readyState === WebSocket.OPEN) return res();
      ws.addEventListener('open', () => res(), { once: true });
    });
    await waitOpen();
    ws.send(JSON.stringify({ type: 'register', name: myName }));

    // ask for notification permission
    if (Notification && Notification.permission !== 'granted') {
      try { await Notification.requestPermission(); } catch(e){}
    }
  };

  // --- toggle local camera
  toggleCamBtn.onclick = () => {
    if (!localStream) return;
    const videoTracks = localStream.getVideoTracks();
    if (!videoTracks || videoTracks.length === 0) return;
    const enabled = videoTracks[0].enabled;
    videoTracks[0].enabled = !enabled;
    if (!enabled) {
      toggleCamBtn.textContent = 'Turn Off Camera';
      // restored video
      const offEl = document.getElementById('local-cam-off');
      if (offEl) offEl.remove();
      localVideo.style.display = '';
    } else {
      // turned off -> show colored box with name
      toggleCamBtn.textContent = 'Turn On Camera';
      localVideo.style.display = 'none';
      const box = document.createElement('div');
      box.className = 'cam-off';
      box.id = 'local-cam-off';
      box.style.background = randomColor();
      box.textContent = myName;
      const localWrapper = document.getElementById('localWrapper');
      localWrapper.appendChild(box);
    }
  };

  function randomColor() {
    const colors = ['#f43f5e','#3b82f6','#10b981','#eab308','#a855f7','#f97316','#ec4899','#22d3ee'];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  // --- Start a direct call to a specific user id
  async function startDirectCall(targetId) {
    if (!localStream) { alert('Start camera first'); return; }
    if (!ws || ws.readyState !== WebSocket.OPEN) { alert('Not connected to signaling'); return; }

    const pc = new RTCPeerConnection(config);
    pcs.set(targetId, pc);
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    pc.ontrack = (ev) => {
      attachRemoteStream(targetId, ev.streams[0], users.get(targetId)?.name || 'User');
    };

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        ws.send(JSON.stringify({ type:'ice-candidate', to: targetId, candidate: e.candidate }));
      }
    };

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    ws.send(JSON.stringify({ type:'call-user', to: targetId, offer }));
    logStatus('Calling ' + (users.get(targetId)?.name || targetId));
  }

  // --- handle incoming call (offer)
  function onIncomingCall(fromId, fromName, offer) {
    currentCallFrom = fromId;
    incomingText.textContent = `${fromName} is calling...`;
    incomingPopup.style.display = 'flex';
    playRing();
    // store offer temporarily
    incomingPopup.dataset.offer = JSON.stringify(offer);
  }

  // accept incoming call
  acceptBtn.onclick = async () => {
    stopRing();
    incomingPopup.style.display = 'none';
    const offer = JSON.parse(incomingPopup.dataset.offer);
    const callerId = currentCallFrom;

    // build pc
    const pc = new RTCPeerConnection(config);
    pcs.set(callerId, pc);
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    pc.ontrack = (ev) => attachRemoteStream(callerId, ev.streams[0], users.get(callerId)?.name || 'User');

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        ws.send(JSON.stringify({ type:'ice-candidate', to: callerId, candidate: e.candidate }));
      }
    };

    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    ws.send(JSON.stringify({ type:'accept-call', to: callerId, answer }));
    logStatus('Call accepted');
  };

  declineBtn.onclick = () => {
    stopRing();
    incomingPopup.style.display = 'none';
    if (currentCallFrom && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type:'decline-call', to: currentCallFrom }));
    }
    currentCallFrom = null;
  };

  async function handleCallAccepted(fromId, answer) {
    const pc = pcs.get(fromId);
    if (!pc) return;
    await pc.setRemoteDescription(new RTCSessionDescription(answer));
    logStatus('Call connected with ' + (users.get(fromId)?.name || fromId));
  }

  function attachRemoteStream(peerId, stream, name) {
    // remove existing if any
    const existing = document.getElementById('video-' + peerId);
    if (existing) existing.remove();

    const wrap = document.createElement('div');
    wrap.className = 'video-wrapper';
    wrap.id = 'video-' + peerId;

    const vid = document.createElement('video');
    vid.autoplay = true; vid.playsinline = true;
    vid.srcObject = stream;

    const lbl = document.createElement('div');
    lbl.className = 'label';
    lbl.textContent = name || (users.get(peerId)?.name || peerId);

    wrap.appendChild(vid);
    wrap.appendChild(lbl);
    videoGrid.appendChild(wrap);
  }

  function playRing() {
    try { ring.currentTime = 0; ring.play(); } catch(e){}
    // browser notification too
    if (Notification && Notification.permission === 'granted' && currentCallFrom && users.get(currentCallFrom)) {
      new Notification('Incoming call', { body: `${users.get(currentCallFrom).name} is calling` });
    }
  }
  function stopRing() { try { ring.pause(); ring.currentTime = 0; } catch(e){} }

  // clean up when peer leaves handled by server 'user-left' message earlier
  // --- helper random color for cam-off placeholders for remote users
  function remoteCamOffBox(peerId, name) {
    const box = document.createElement('div');
    box.className = 'cam-off';
    box.style.background = randomColor();
    box.textContent = name;
    return box;
  }

  // Escape HTML helper defined above reused
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[m]); }

  // On page unload, inform server optionally
  window.addEventListener('beforeunload', () => {
    try { if (ws && ws.readyState === WebSocket.OPEN) ws.close(); } catch(e){}
  });

  // Utility: copy of randomColor used earlier
  function randomColor() {
    const colors = ['#f43f5e','#3b82f6','#10b981','#eab308','#a855f7','#f97316','#ec4899','#22d3ee'];
    return colors[Math.floor(Math.random() * colors.length)];
  }
  </script>
</body>
</html>
